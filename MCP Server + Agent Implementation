import asyncio
import json
import sqlite3
from datetime import datetime
from pathlib import Path

from database_setup import DatabaseSetup

DB_PATH = Path("support.db")

def ensure_db_initialized() -> None:
    if not DB_PATH.exists():
        print("[MCP] support.db not found, initializing via database_setup.py...")
        db = DatabaseSetup(str(DB_PATH))
        db.connect()
        db.create_tables()
        db.create_triggers()
        db.insert_sample_data()
        db.close()
        print("[MCP] support.db created with sample data.")

def get_db() -> sqlite3.Connection:
    ensure_db_initialized()
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn

# MCP server: tools + list_tools + call_tool + stdio endpoint

from mcp.server import Server
from mcp.server.stdio import stdio_server
import mcp.types as types

server = Server("customer-service-mcp")

async def get_customer_impl(customer_id: int) -> dict:
    """
    Tool: get_customer(customer_id) - uses customers.id
    """
    conn = get_db()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, name, email, phone, status, created_at, updated_at
        FROM customers
        WHERE id = ?
        """,
        (customer_id,),
    )
    row = cur.fetchone()
    conn.close()

    if row is None:
        return {"error": f"Customer {customer_id} not found"}

    return {
        "id": row["id"],
        "name": row["name"],
        "email": row["email"],
        "phone": row["phone"],
        "status": row["status"],
        "created_at": row["created_at"],
        "updated_at": row["updated_at"],
    }

async def list_customers_impl(status: str = "active", limit: int = 50) -> list:
    """
    Tool: list_customers(status, limit) - uses customers.status
    """
    conn = get_db()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, name, email, phone, status, created_at, updated_at
        FROM customers
        WHERE status = ?
        LIMIT ?
        """,
        (status, limit),
    )
    rows = cur.fetchall()
    conn.close()

    return [
        {
            "id": r["id"],
            "name": r["name"],
            "email": r["email"],
            "phone": r["phone"],
            "status": r["status"],
            "created_at": r["created_at"],
            "updated_at": r["updated_at"],
        }
        for r in rows
    ]

async def update_customer_impl(customer_id: int, data: dict) -> dict:
    """
    Tool: update_customer(customer_id, data) - uses customers fields
    """
    allowed_fields = {"name", "email", "phone", "status"}
    updates = []
    params = []

    for key, value in data.items():
        if key in allowed_fields:
            updates.append(f"{key} = ?")
            params.append(value)

    if not updates:
        return {"error": "No valid fields to update"}

    params.append(customer_id)

    conn = get_db()
    cur = conn.cursor()
    sql = f"""
        UPDATE customers
        SET {", ".join(updates)}
        WHERE id = ?
    """
    cur.execute(sql, params)
    conn.commit()
    conn.close()

    return {
        "success": True,
        "updated_fields": list(data.keys()),
    }

async def create_ticket_impl(
    customer_id: int, issue: str, priority: str = "medium"
) -> dict:
    """
    Tool: create_ticket(customer_id, issue, priority) - uses tickets fields
    """
    if priority not in ("low", "medium", "high"):
        return {"error": "priority must be one of 'low', 'medium', 'high'"}

    created_at = datetime.utcnow().isoformat()

    conn = get_db()
    cur = conn.cursor()
    cur.execute(
        """
        INSERT INTO tickets (customer_id, issue, status, priority, created_at)
        VALUES (?, ?, 'open', ?, ?)
        """,
        (customer_id, issue, priority, created_at),
    )
    ticket_id = cur.lastrowid
    conn.commit()
    conn.close()

    return {
        "ticket_id": ticket_id,
        "customer_id": customer_id,
        "issue": issue,
        "status": "open",
        "priority": priority,
        "created_at": created_at,
    }

async def get_customer_history_impl(customer_id: int) -> list:
    """
    Tool: get_customer_history(customer_id) - uses tickets.customer_id
    """
    conn = get_db()
    cur = conn.cursor()
    cur.execute(
        """
        SELECT id, customer_id, issue, status, priority, created_at
        FROM tickets
        WHERE customer_id = ?
        ORDER BY created_at DESC
        """,
        (customer_id,),
    )
    rows = cur.fetchall()
    conn.close()

    return [
        {
            "id": r["id"],
            "customer_id": r["customer_id"],
            "issue": r["issue"],
            "status": r["status"],
            "priority": r["priority"],
            "created_at": r["created_at"],
        }
        for r in rows
    ]

# list_tools for MCP server
@server.list_tools()
async def list_tools() -> list:
    """
    Expose available tools and their JSON input schemas to MCP clients.
    """
    return [
        types.Tool(
            name="get_customer",
            description="Get customer information by ID",
            inputSchema={
                "type": "object",
                "properties": {
                    "customer_id": {"type": "integer"},
                },
                "required": ["customer_id"],
            },
        ),
        types.Tool(
            name="list_customers",
            description="List customers filtered by status",
            inputSchema={
                "type": "object",
                "properties": {
                    "status": {
                        "type": "string",
                        "enum": ["active", "disabled"],
                        "default": "active",
                    },
                    "limit": {
                        "type": "integer",
                        "default": 50,
                    },
                },
            },
        ),
        types.Tool(
            name="update_customer",
            description="Update customer fields (name, email, phone, status)",
            inputSchema={
                "type": "object",
                "properties": {
                    "customer_id": {"type": "integer"},
                    "data": {
                        "type": "object",
                        "description": "Fields to update on the customer",
                    },
                },
                "required": ["customer_id", "data"],
            },
        ),
        types.Tool(
            name="create_ticket",
            description="Create a support ticket for a customer",
            inputSchema={
                "type": "object",
                "properties": {
                    "customer_id": {"type": "integer"},
                    "issue": {"type": "string"},
                    "priority": {
                        "type": "string",
                        "enum": ["low", "medium", "high"],
                        "default": "medium",
                    },
                },
                "required": ["customer_id", "issue"],
            },
        ),
        types.Tool(
            name="get_customer_history",
            description="Get ticket history for a customer",
            inputSchema={
                "type": "object",
                "properties": {
                    "customer_id": {"type": "integer"},
                },
                "required": ["customer_id"],
            },
        ),
    ]

# call_tool for MCP server
@server.call_tool()
async def call_tool(name: str, arguments: dict) -> list:
    """
    Dispatch tool calls from MCP clients to the corresponding implementation.
    """
    if name == "get_customer":
        result = await get_customer_impl(arguments["customer_id"])
    elif name == "list_customers":
        result = await list_customers_impl(
            status=arguments.get("status", "active"),
            limit=arguments.get("limit", 50),
        )
    elif name == "update_customer":
        result = await update_customer_impl(
            customer_id=arguments["customer_id"],
            data=arguments.get("data", {}),
        )
    elif name == "create_ticket":
        result = await create_ticket_impl(
            customer_id=arguments["customer_id"],
            issue=arguments["issue"],
            priority=arguments.get("priority", "medium"),
        )
    elif name == "get_customer_history":
        result = await get_customer_history_impl(arguments["customer_id"])
    else:
        result = {"error": f"Unknown tool: {name}"}

    return [
        types.TextContent(
            type="text",
            text=json.dumps(result, ensure_ascii=False, indent=2),
        )
    ]

async def run_mcp_stdio():
    print("[MCP] Starting MCP stdio server (tools/list, tools/call available)...")
    async with stdio_server() as (read, write):
        await server.run(
            read,
            write,
            initialization_options={}
        )

async def demo_mcp_tools():
    """
    Local demo (no MCP client) just to sanity check tools.
    """
    print("=== list_tools() ===")
    tools = await list_tools()
    for t in tools:
        print("-", t.name, ":", t.description)

    print("\n=== call_tool('get_customer', {customer_id: 1}) ===")
    res = await call_tool("get_customer", {"customer_id": 1})
    print(res[0].text)

    print("\n=== call_tool('list_customers', {'status': 'active', 'limit': 3}) ===")
    res = await call_tool("list_customers", {"status": "active", "limit": 3})
    print(res[0].text)

    print("\n=== call_tool('create_ticket', {...}) ===")
    res = await call_tool(
        "create_ticket",
        {"customer_id": 1, "issue": "Billing issue from demo()", "priority": "high"},
    )
    print(res[0].text)

    print("\n=== call_tool('get_customer_history', {customer_id: 1}) ===")
    res = await call_tool("get_customer_history", {"customer_id": 1})
    print(res[0].text)

# Agents

import re
import json
import asyncio

def log(msg: str):
    print(msg)

# Customer Data Agent
async def customer_data_agent(task: dict) -> dict:
    t = task["type"]

    if t == "get_customer":
        cid = task["customer_id"]
        log(f"[Router -> DataAgent] Request: get_customer({cid})")
        res = await call_tool("get_customer", {"customer_id": cid})
        data = json.loads(res[0].text)
        log(f"[DataAgent -> Router] Response: customer {cid} loaded")
        return data

    elif t == "list_premium_customers":
        # Here "premium customers" is approximated as active customers
        log("[Router -> DataAgent] Request: list_customers(status='active')")
        res = await call_tool("list_customers", {"status": "active", "limit": 100})
        customers = json.loads(res[0].text)
        log(f"[DataAgent -> Router] Response: {len(customers)} active customers")
        return customers

    elif t == "get_history":
        cid = task["customer_id"]
        log(f"[Router -> DataAgent] Request: get_customer_history({cid})")
        res = await call_tool("get_customer_history", {"customer_id": cid})
        history = json.loads(res[0].text)
        log(f"[DataAgent -> Router] Response: {len(history)} tickets for customer {cid}")
        return history

    elif t == "update_email":
        cid = task["customer_id"]
        new_email = task["new_email"]
        log(f"[Router -> DataAgent] Request: update_customer({cid}, email={new_email})")
        res = await call_tool(
            "update_customer",
            {"customer_id": cid, "data": {"email": new_email}},
        )
        resp = json.loads(res[0].text)
        log(f"[DataAgent -> Router] Response: email updated for customer {cid}")
        return resp

    else:
        raise ValueError(f"Unknown data task type: {t}")

# Support Agent

async def support_agent(task: dict) -> str:
    scenario = task["scenario"]

    if scenario == "account_help":
        customer = task["customer"]
        name = customer.get("name", "there")
        return (
            f"Hi {name}, I’ve pulled up your account and confirmed it’s currently "
            f"{customer.get('status', 'active')}. How can I help you with your account today?"
        )

    if scenario == "account_upgrade":
        customer = task["customer"]
        name = customer.get("name", "there")
        return (
            f"Hi {name}, I’ve pulled up your account and confirmed it’s currently "
            f"{customer.get('status', 'active')}. I can help you upgrade your account — "
            "for example by enabling premium features, increasing limits, or adjusting your plan. "
            "What kind of upgrade are you looking for?"
        )

    if scenario == "billing_cancel":
        customer = task.get("customer")
        tickets = task.get("tickets", [])
        name = customer.get("name", "there") if customer else "there"
        billing_related = [
            t for t in tickets
            if "billing" in t["issue"].lower() or "charge" in t["issue"].lower()
        ]

        if billing_related:
            summary = "; ".join(f"#{t['id']}: {t['issue']}" for t in billing_related[:3])
            extra = " There are additional related tickets as well." if len(billing_related) > 3 else ""
            billing_text = f"I see {len(billing_related)} billing-related ticket(s): {summary}.{extra}"
        else:
            billing_text = "I don’t see any existing billing tickets yet, so I’ll document this issue now."

        return (
            f"Hi {name}, I’m sorry you’re having billing issues and want to cancel. "
            f"{billing_text} I can help cancel your subscription and ensure any duplicate "
            f"charges are reviewed and refunded if appropriate."
        )

    if scenario == "tickets_report":
        tickets = task["high_priority_open_tickets"]
        if not tickets:
            return "There are currently no high-priority open tickets for active customers."
        lines = []
        for t in tickets:
            lines.append(
                f"- Ticket #{t['id']} | Customer {t['customer_id']} | "
                f"Issue: {t['issue']} | Status: {t['status']}"
            )
        joined = "\n".join(lines)
        return (
            "Here is the report of high-priority open tickets for active customers:\n"
            f"{joined}"
        )

    if scenario == "active_open_customers":
        customers = task["customers_with_open_tickets"]
        if not customers:
            return "There are no active customers with open tickets at the moment."
        lines = []
        for c in customers:
            cid = c["id"]
            name = c["name"]
            open_count = c["open_ticket_count"]
            lines.append(f"- Customer #{cid} ({name}): {open_count} open ticket(s)")
        joined = "\n".join(lines)
        return (
            "Here is the list of active customers who currently have open tickets:\n"
            f"{joined}"
        )

    if scenario == "update_and_show_history":
        customer = task["customer"]
        history = task["history"]
        new_email = task["new_email"]
        name = customer.get("name", "there")
        ticket_summaries = [
            f"#{t['id']} [{t['status']}/{t['priority']}]: {t['issue']}"
            for t in history[:5]
        ]
        history_text = "\n".join(ticket_summaries) if ticket_summaries else "No tickets on file."
        more = " (showing latest 5)" if len(history) > 5 else ""
        return (
            f"Hi {name}, I’ve updated your email to {new_email} successfully.\n\n"
            f"Here is your ticket history{more}:\n{history_text}"
        )

    if scenario == "urgent_refund":
        customer = task.get("customer")
        tickets = task.get("tickets", [])
        name = customer.get("name", "there") if customer else "there"

        billing_related = [
            t for t in tickets
            if "billing" in t["issue"].lower() or "charge" in t["issue"].lower()
        ]
        if billing_related:
            summary = "; ".join(f"#{t['id']}: {t['issue']}" for t in billing_related[:3])
            billing_text = (
                f"I see existing billing/charge-related ticket(s) on your account: {summary}. "
            )
        else:
            billing_text = "I don’t see previous billing tickets yet, so I’ll create or escalate a new case. "

        return (
            f"Hi {name}, I’m very sorry that you’ve been charged twice. "
            "I’m treating this as an urgent request and will escalate it as a high-priority billing case. "
            f"{billing_text}"
            "We’ll review the duplicate charges immediately and process a refund if confirmed."
        )

    raise ValueError(f"Unknown support scenario: {scenario}")

# Router Agent

async def router_agent(user_query: str) -> str:
    q = user_query.lower().strip()
    log(f"\n Router received query: {user_query!r}")

    # Scenario 1 Task Allocation
    m_account_help = re.search(
        r"need help with my account.*customer id\s+(\d+)", q
    )
    if m_account_help:
        customer_id = int(m_account_help.group(1))
        log(f"[Router -> DataAgent] Task allocation: get_customer({customer_id}) for account_help")
        customer = await customer_data_agent({"type": "get_customer", "customer_id": customer_id})
        if "error" in customer:
            return f"Customer {customer_id} not found."

        log("[Router -> SupportAgent] Scenario: account_help")
        reply = await support_agent({"scenario": "account_help", "customer": customer})
        log("[SupportAgent -> Router] Account help message ready.")
        return reply

    # 1. Simple Query
    # "Get customer information for ID 5"
    m_simple = re.search(r"get customer information for id\s+(\d+)", q)
    if m_simple:
        customer_id = int(m_simple.group(1))
        log(f"[Router -> DataAgent] SimpleQuery: get_customer({customer_id})")
        customer = await customer_data_agent({"type": "get_customer", "customer_id": customer_id})
        if "error" in customer:
            return f"Customer {customer_id} not found."
        return (
            f"Customer #{customer['id']} — {customer['name']}\n"
            f"Email: {customer['email']}\n"
            f"Phone: {customer['phone']}\n"
            f"Status: {customer['status']}"
        )

    # 2. Scenario 3 (Multi-Step high-priority report):
    # "What's the status of all high-priority tickets for premium customers?"
    if (
        ("high-priority" in q or "high priority" in q)
        and "tickets" in q
        and "premium" in q
    ):
        log("[Router -> DataAgent] Multi-step: list premium (active) customers")
        customers = await customer_data_agent({"type": "list_premium_customers"})
        high_priority_open_tickets = []

        for c in customers:
            cid = c["id"]
            history = await customer_data_agent({"type": "get_history", "customer_id": cid})
            for t in history:
                if t["priority"] == "high" and t["status"] in ("open", "in_progress"):
                    high_priority_open_tickets.append(t)

        log(f"[Router] Found {len(high_priority_open_tickets)} high-priority tickets for premium customers.")
        log("[Router -> SupportAgent] Scenario: tickets_report")
        reply = await support_agent({
            "scenario": "tickets_report",
            "high_priority_open_tickets": high_priority_open_tickets,
        })
        log("[SupportAgent -> Router] High-priority tickets report ready.")
        return reply

    # 3. Coordinated Query
    # "I'm customer 12345 and need help upgrading my account"
    m_upgrade = re.search(r"i[' ]m customer\s+(\d+)", q)
    if m_upgrade and "account" in q and "upgrad" in q:
        customer_id = int(m_upgrade.group(1))
        log(f"[Router -> DataAgent] Coordinated: get_customer({customer_id}) for upgrade help")
        customer = await customer_data_agent({"type": "get_customer", "customer_id": customer_id})

        log("[Router -> SupportAgent] Scenario: account_upgrade")
        reply = await support_agent({"scenario": "account_upgrade", "customer": customer})
        log("[SupportAgent -> Router] Coordinated upgrade message ready.")
        return reply

    # 4. Complex Query
    # "Show me all active customers who have open tickets"
    if "active customers" in q and "open tickets" in q:
        log("[Router -> DataAgent] Complex: list_customers(status='active')")
        customers = await customer_data_agent({"type": "list_premium_customers"})  # active ~ premium here

        customers_with_open = []
        for c in customers:
            cid = c["id"]
            history = await customer_data_agent({"type": "get_history", "customer_id": cid})
            open_tickets = [t for t in history if t["status"] == "open"]
            if open_tickets:
                customers_with_open.append({
                    "id": cid,
                    "name": c["name"],
                    "open_ticket_count": len(open_tickets),
                })
        log(f"[Router] Found {len(customers_with_open)} active customers with open tickets.")

        log("[Router -> SupportAgent] Scenario: active_open_customers")
        reply = await support_agent({
            "scenario": "active_open_customers",
            "customers_with_open_tickets": customers_with_open,
        })
        log("[SupportAgent -> Router] Complex query report ready.")
        return reply

    # 5. Story Scenario 2: Negotiation/Escalation
    # "I want to cancel my subscription but I'm having billing issues"
    if "cancel" in q and "billing" in q:
        customer_id = 1  # demo: assume current user is customer 1
        log(f"[Router] Negotiation/Escalation detected for customer {customer_id}.")
        log("[Router -> SupportAgent] Can you handle this cancellation + billing issue?")
        log("[SupportAgent -> Router] I need billing context for this customer (simulated).")

        customer = await customer_data_agent({"type": "get_customer", "customer_id": customer_id})
        history = await customer_data_agent({"type": "get_history", "customer_id": customer_id})

        log("[Router -> SupportAgent] Scenario: billing_cancel with billing context")
        reply = await support_agent({
            "scenario": "billing_cancel",
            "customer": customer,
            "tickets": history,
        })
        log("[SupportAgent -> Router] Billing cancel negotiation response ready.")
        return reply

    # 6. Escalation
    # "I've been charged twice, please refund immediately!"
    if "charged twice" in q and "refund" in q:
        # Demo: assume current user is customer_id=1
        customer_id = 1
        log(f"[Router] Escalation detected for customer {customer_id}.")
        customer = await customer_data_agent({"type": "get_customer", "customer_id": customer_id})
        history = await customer_data_agent({"type": "get_history", "customer_id": customer_id})

        log("[Router -> SupportAgent] Scenario: urgent_refund")
        reply = await support_agent({
            "scenario": "urgent_refund",
            "customer": customer,
            "tickets": history,
        })
        log("[SupportAgent -> Router] Urgent escalation message ready.")
        return reply

    # 7. Multi-Intent
    # "Update my email to new@email.com and show my ticket history"
    m_email = re.search(r"update my email to\s+([^\s]+)", q)
    if m_email and "ticket history" in q:
        new_email = m_email.group(1)
        customer_id = 1  # assume current user is customer 1
        log(f"[Router] Multi-intent detected: update_email + show_history for customer {customer_id}")

        customer = await customer_data_agent({"type": "get_customer", "customer_id": customer_id})

        log("[Router] Running email update and ticket history fetch in parallel...")
        update_task = customer_data_agent({
            "type": "update_email",
            "customer_id": customer_id,
            "new_email": new_email,
        })
        history_task = customer_data_agent({
            "type": "get_history",
            "customer_id": customer_id,
        })
        _update_res, history = await asyncio.gather(update_task, history_task)
        log("[Router] Both email update and history fetch completed.")

        log("[Router -> SupportAgent] Scenario: update_and_show_history")
        reply = await support_agent({
            "scenario": "update_and_show_history",
            "customer": customer,
            "history": history,
            "new_email": new_email,
        })
        log("[SupportAgent -> Router] Final multi-intent message ready.")
        return reply

    # Fallback
    return (
        "Sorry, I couldn’t automatically route your request. "
        "Please include your customer ID or specify if it's about billing, account help, tickets, "
        "or updating your email."
    )

async def run_assignment_test_scenarios():
    """
    End-to-end demo: runs ALL required scenarios
    - 5 assignment test scenarios
    - 3 scenarios from Part 3
    """

    # 5 official test scenarios from assignment
    test_queries = [
        # Simple Query
        "Get customer information for ID 5",
        # Coordinated Query (upgrade)
        "I'm customer 1 and need help upgrading my account",
        # Complex Query (active customers with open tickets)
        "Show me all active customers who have open tickets",
        # Escalation (charged twice, urgent refund)
        "I've been charged twice, please refund immediately!",
        # Multi-Intent (update email + ticket history)
        "Update my email to new_email@example.com and show my ticket history",
    ]

    # 3 scenarios from Part 3 (Task allocation / Negotiation / Multi-step)
    story_queries = [
        # Scenario 1: Task allocation
        "I need help with my account, customer ID 3",
        # Scenario 2: Negotiation / Escalation (cancel + billing issues)
        "I want to cancel my subscription but I'm having billing issues",
        # Scenario 3: Multi-step high-priority tickets for premium customers
        "What's the status of all high-priority tickets for premium customers?",
    ]

    all_queries = test_queries + story_queries

    for idx, q in enumerate(all_queries, start=1):
        print("\n" + "=" * 80)
        print(f" Scenario #{idx}: {q!r}")
        answer = await router_agent(q)
        print("\n[Final Answer to User]")
        print(answer)
        print("=" * 80 + "\n")

# A2A Agent interfaces

try:
    from python_a2a import (
        A2AServer,
        agent as a2a_agent,
        skill as a2a_skill,
        run_server,
        TaskStatus,
        TaskState,
    )

    A2A_AVAILABLE = True
except ImportError:
    A2A_AVAILABLE = False
    A2AServer = object
    def a2a_agent(*args, **kwargs):
        def deco(cls):
            return cls
        return deco

    def a2a_skill(*args, **kwargs):
        def deco(fn):
            return fn
        return deco

    def run_server(*args, **kwargs):
        raise RuntimeError("a2a is not installed; please pip install 'a2a[all]'")

    class TaskStatus:
        def __init__(self, state, message=None):
            self.state = state
            self.message = message

    class TaskState:
        COMPLETED = "COMPLETED"
        INPUT_REQUIRED = "INPUT_REQUIRED"

if A2A_AVAILABLE:
    @a2a_agent(
        name="Customer Data Agent",
        description="MCP-backed customer data access (get, list, history, update)",
        version="1.0.0",
    )
    class CustomerDataA2A(A2AServer):
        """
        A2A wrapper for the Customer Data Agent.

        Exposes a generic 'data_task' skill:
        - expects task.message.content to be a dict like {"type": "...", ...}
        - internally calls the same customer_data_agent() logic which uses MCP tools.
        """

        @a2a_skill(
            name="data_task",
            description="Handle customer data tasks (get_customer, list_premium_customers, get_history, update_email)",
            tags=["customer", "data", "mcp"],
        )
        def data_task(self, payload: dict) -> dict:
            return payload

        async def handle_task(self, task):
            message_data = task.message or {}
            content = message_data.get("content", {})
            if isinstance(content, dict):
                data_task = content
            else:
                data_task = {"type": "unknown", "raw": str(content)}

            result = await customer_data_agent(data_task)

            task.artifacts = [
                {
                    "parts": [
                        {
                            "type": "text",
                            "text": json.dumps(result, ensure_ascii=False, indent=2),
                        }
                    ]
                }
            ]
            task.status = TaskStatus(state=TaskState.COMPLETED)
            return task


    @a2a_agent(
        name="Support Agent",
        description="General customer support, escalation, and reporting.",
        version="1.0.0",
    )
    class SupportA2A(A2AServer):
        """
        A2A wrapper for the Support Agent.

        Exposes a 'support_scenario' skill, where content describes scenario + payload.
        """

        @a2a_skill(
            name="support_scenario",
            description="Handle support scenarios (account_upgrade, billing_cancel, tickets_report, urgent_refund, etc.)",
            tags=["support", "tickets"],
        )
        def support_scenario(self, payload: dict) -> dict:
            return payload

        async def handle_task(self, task):
            message_data = task.message or {}
            content = message_data.get("content", {})
            if isinstance(content, dict):
                support_task = content
            else:
                support_task = {"scenario": "unknown", "raw": str(content)}

            reply_text = await support_agent(support_task)

            task.artifacts = [
                {
                    "parts": [
                        {
                            "type": "text",
                            "text": reply_text,
                        }
                    ]
                }
            ]
            task.status = TaskStatus(state=TaskState.COMPLETED)
            return task


    @a2a_agent(
        name="Router Agent",
        description="Orchestrator that routes user queries to Customer Data and Support agents.",
        version="1.0.0",
    )
    class RouterA2A(A2AServer):
        """
        A2A wrapper for the Router Agent.

        As an A2A agent, it:
        - Receives user query as task.message.content.text
        - Calls underlying router_agent() (which itself coordinates Data & Support)
        - Returns final answer in artifacts.
        """

        @a2a_skill(
            name="route_query",
            description="Route a free-form customer service query to specialized agents.",
            tags=["router", "orchestrator", "multi-agent"],
        )
        def route_query(self, text: str) -> str:
            return text

        async def handle_task(self, task):
            message_data = task.message or {}
            content = message_data.get("content", {})
            if isinstance(content, dict):
                text = content.get("text", "")
            else:
                text = str(content)

            answer = await router_agent(text)

            task.artifacts = [
                {
                    "parts": [
                        {
                            "type": "text",
                            "text": answer,
                        }
                    ]
                }
            ]
            task.status = TaskStatus(state=TaskState.COMPLETED)
            return task

    def run_customer_data_a2a_server(port: int = 8001):
        """
        Run Customer Data Agent as an A2A server.
        """
        agent = CustomerDataA2A()
        print(f"[A2A] Starting Customer Data Agent on port {port} ...")
        run_server(agent, port=port)

    def run_support_a2a_server(port: int = 8002):
        agent = SupportA2A()
        print(f"[A2A] Starting Support Agent on port {port} ...")
        run_server(agent, port=port)

    def run_router_a2a_server(port: int = 8000):
        agent = RouterA2A()
        print(f"[A2A] Starting Router Agent on port {port} ...")
        run_server(agent, port=port)

if __name__ == "__main__":
    import sys
    mode = sys.argv[1] if len(sys.argv) > 1 else "demo"

    if mode == "mcp":
        asyncio.run(run_mcp_stdio())
    elif mode == "demo":
        asyncio.run(run_assignment_test_scenarios())
